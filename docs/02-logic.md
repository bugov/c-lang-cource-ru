# Управление потоком выполнения

Пока что мы писали крайне простые программы, где всё было линейно. И это
прекрасно, но ценность таких программ часто низка. Поэтому в рамках
данного занятия рассмотрим следующие темы:

- Управляющие конструкции
- Циклы

## Управляющие конструкции

В Си выражение типа `a = 1;` – оператор, а точка с запятой – обязательная
завершающая часть оператора. Фигурные скобки – группировка операторов в блоки,
синтаксически эквивалентные одному оператору. Мы уже выдели это на предыдущей
лекции – при объявлении функции `main`.

### Оператор if-else

Оператор if-else определяет процесс принятия альтернативных решений.

```C
if (выражение)
  оператор1
else
  оператор2
```

Ветка else необязательна. В случае, если выражение истинно, то выполнится
оператор1, иначе – оператор2. После чего продолжится выполнение программы
после блока if.

Например,

```C
#include <stdio.h>

int main(void) {
    int a;
    int b;
    scanf("%d %d", &a, &b);  // Кладём в a и b два числа со стандартного ввода.

    if (b == 0) {
        return 1;
    }
    else {
        printf("%d\n", a / b);
    }

    return 0;
}
```

**Истина** – всего лишь ненулевое значение. 0 = ложь (ну и NULL, но об этом
позже).

Более сложный вариант:

```C
// ещё вариант определения переменных (плохой)
float a = 1, b = 2;
if (a)
    if (b / a < 1)
        return a;
else
    return 0;
return b;
```

– довольно вычурный вариант вернуть максимум, либо `0` в случае, если `a == 0`.
К тому же неверный – найдите ошибку.

Более корректный вариант:

```C
float a = 1;
float b = 2;

if (a) {
    if (b / a < 1) {
      return a;
    }
}
else {
    return 0;
}

return b;
```

– фигурные скобки явно указывают, что к чему (`else` применяется к ближайшему
`if`) – используйте их!

### else-if

```C
if (выражение1)
  оператор1
else if (выражение2)
  оператор2
else
  оператор3
```

– эта конструкция – объединение нескольких операторов if-else.
Один из способов задать более 2-х вариантов развития событий (аналог elif).

На паре возник вопрос: а что может стоять в параметрах функции main вместо void.
В следующем примере не всё будет досконально понятно, но общее понимание должно быть.

```C
int main (
    int argc,  // количество агрументов
    char *argv[]  // массив указателей на символы - аргументы вызова программы
) {
    if (argc != 3) {
        return 1;
    }

    char a;
    char b;
    for (int count = 1; count < argc; count++) {
        if (count == 1) {
            a = argv[count][0];  // получаем первый символ 1-го аргумента
        }

        if (count == 2) {
            b = argv[count][0];  // получаем первый символ 2-го аргумента
        }
    }

    if (a < b) {
        return 1;
    }
    else if (a == b) {
        return 0;
    }
    else {
        return 2;
    }
}
```

### Оператор switch

Аналог оператора if-else на много альтернативных вариантов выполнения.
Однако, так как используются не любые выражения, а только константы,
сильно оптимизирован.

```C
switch (выражение) {
case константа1:
  операторы1
case константа2:
  операторы2
default:
  операторы3
}
```

Идём сверху вниз и проверяем на соответствие константе. В случае соответствия,
выполняются операторы (не оператор, а операторы!). Чтобы остановить проверку
(а она продолжится далее), вызываем `break` – он прерывает поток выполнения
циклов или оператора `switch`, возвращаясь на уровень выше.

Если никто так нас и не остановил, а варианты закончились – переходим к
"ветке" `default`.

Пример кода для получения текста "комментарий/комментариев" в зависимости от их
числа:

```C
#include <stdio.h>

int main (void) {
  unsigned a = 1;
  char *text;  // Указатель на символы - поймём позднее

  switch (a % 10) {
  case 1:
    text = "комментарий";
    break;
  case 2:
  case 3:
  case 4:
    text = "комментария";
    break;
  case 5: case 6: case 7: case 8: case 9: case 0:
    text = "комментариев";
  default:
    return 1;
  }

  puts(text);

  return 0;
}
```

Пока смотрим только на оператор switch. Всё остальное – чтобы заработал пример,
а сам пример не был бы совсем выдуманным.

## Циклы

Одна из задач компьютеров после обсчёта ядерных взрывов – автоматизация
рутинных повторяющихся операций. А если мы говорим о повторении, то самое время
поговорить о циклах.

### while

В общем виде while выглядит так:

```C
while (выражение1)
    оператор1
```

Если выражение1 истинно, то выполняем оператор1, пока выражение1 не станет
ложным, либо пока нас не остановят оператором break.

```C
unsigned x = 0;  // unsigned int
unsigned y = 0;  // беззнаковое целочисленное

while (x <= y) {
    x = y;
    y++;
}
```

Когда остановится цикл? Правильно, когда y переполнится. В x будет лежать
самое большое unsigned число.

### for

Также известен как "Сишный for":

```C
for (выражение1; выражение2; выражение3)
    оператор1;
```

Выражение1 выполняется при старте работы цикла.

Выражение2 – условия остановки цикла.

Выражение3 выполняется каждыую итерацию цикла.

Стандартный пример – обход элементов массива, но это будет на следующей паре.
Сейчас же – посчитаем факториал:

```C
unsigned fact = 1;
for (int iter = 1; iter <= 5; iter++) {
    fact = fact * iter;
}
```

Мы можем также сделать это через while:

```C
unsigned fact = 1;
int iter = 1;

while (iter <= 5) {
    fact = fact * iter;
    iter++;
}
```

А предыдущий пример мы можем записать на for вместо while:

```C
unsigned x = 0;
unsigned y = 0;

for (; x < y; y++) {
    x = y;
}
```

### do-while

```C
do
    оператор1;
while (выражение1);
```

В отличии от `while`, `do-while` выполняет 1 раз оператор1, далее – проверяет
выражение1 и, если оно истинно, снова выполняет оператор1, пока выражение1
не станет ложным.

### break и continue

Оператор `break` мы уже видели – он прерывает работу цикла или `switch`,
выполнение продолжится с оператора, следующего за циклом или `switch`.

`continue` также вмешивается в работу цикла, но не прерывает его полностью –
он переводит к следющей итерации цикла.

```C
for (int i = 0; i < 100; i++) {
    if (i % 2) {
        continue;
    }

    printf("%d\n", i);
}
```

Если `i` нечётное – пропускаем. Если чётное – продолжаем, то есть печатаем.

## ДЗ

Написать утилиту, позволяющую считать статистику по символам: цифры, латиница.

Пример работы:

```Bash
→ cat /etc/passwd | ./counter
Digits: 12
Latin symbols: 112
```

Подсказка. Читать символы можно функцией `getc` из `stdio`, читать нужно из `stdin`,
а символ конца ввода – `EOF`.

```C
while ((c = getc(stdin)) != EOF)
```

