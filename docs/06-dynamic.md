# Динимическая работа с памятью

До этого мы выделяли статичесие объёмы памяти:

```C
int a;
char b[10];
struct Point2d = { -1, 1 };
```

– в каждом из перечисленных случаем компилятор знает, сколько нужно выделить
памяти под наши переменные. Более того, зная, что обасть видимости переменной
– блок `{}`, компилятор также знает, когда память можно освободить.

## Модель памяти Си

Модель памяти – по сути набор правил: как создавать переменные, где они
доступны, сколько под них выделять и когда удалять.

+---------------+--------------------------------------+------------------------------------------+--------------------------+
|  	            | Автоматический тип	                 | Статический тип                          | Динамический тип         |
+---------------+--------------------------------------+------------------------------------------+--------------------------+
| Объявление    | Объект без связывания и static       | Имеет связывание или объявлен как static | Выделен с помощью *alloc |
+---------------+--------------------------------------+------------------------------------------+--------------------------+
| Время жизни   | Блок, в котором объявлена переменная | Время работы программы                   | От *alloc до free        |
+---------------+--------------------------------------+------------------------------------------+--------------------------+
| Инициализация | Отсутствует                          | Один раз до запуска программы            | Частично в случае calloc |
+---------------+--------------------------------------+------------------------------------------+--------------------------+
| Размер	      | Фиксированный, неизменяемый          | Фиксированный, неизменяемый              | Любой, изменяемый        |
+---------------+--------------------------------------+------------------------------------------+--------------------------+

```C
#include <stdio.h>

void foo() {
  int a = 10;
  static int sa = 10;

  a += 5;
  sa += 5;

  printf("a = %d, sa = %d\n", a, sa);
}

int main() {
  int i;

  for (i = 0; i < 10; ++i) {
    foo();
  }
}
```

– можно заметить, что `sa` инициализировался 1 раз, после чего уже использовался
повторно:

```
a = 15, sa = 15
a = 15, sa = 20
a = 15, sa = 25
a = 15, sa = 30
a = 15, sa = 35
a = 15, sa = 40
a = 15, sa = 45
a = 15, sa = 50
a = 15, sa = 55
a = 15, sa = 60
```

## Динамическое выделение памяти

Как мы работали с массивами раньше? `int a[BIG_SISE]` Как мы работаем сейчас?
Выделяем столько, сколько нужно:

```C
#include <stdio.h>
#include <stdlib.h>

int main() {
  size_t size;
  int *list;

  scanf("%lu", &size);
  list = (int *)malloc(size * sizeof(int));

  for (int i = 0; i < size; ++i) {
    scanf("%d", list + i);
  }

  for (int i = 0; i < size; ++i) {
    printf("%d", *(list + i));
  }

  free(list);
} //*
```

Опять же можно почитать `man malloc`.

```
void * malloc(size_t size);
```


Но в общем и целом это функция,
выделяет size байт неинициализированной памяти (не нулики, а треш).

Если выделение прошло успешно, то возвращается указатель на самый первый байт выделенной памяти.

Если неуспешно – NULL. Также `errno` будет равен `ENOMEM` То есть правильнее было написать:

```C
#include <stdio.h>
#include <stdlib.h>

int main() {
  size_t size;
  int *list;

  scanf("%lu", &size);
  list = (int *)malloc(size * sizeof(int));

  if (list == NULL) {
    goto error;
  }

  for (int i = 0; i < size; ++i) {
    scanf("%d", list + i);
  }

  for (int i = 0; i < size; ++i) {
    printf("%d", *(list + i));
  }

  free(list);
  return 0;

error:
  return 1;
} //*
```

Очищать NULL указатель не нужно

```C
#include <stdlib.h>

int main() {
  free(NULL);
}
```

– в том же clang всё пройдёт нормально (сделает ничто), но в более экзотических
случаях вполне может крэшнуть программу.

Рядом с `malloc` и `free` в мане можно увидеть ещё:

- `void * calloc (size_t count, size_t size);`

  Последовательно выделяет достаточно места для `count` объектов размером `size` байт.
  Выделенная память заполняется байтами нулевого значения.

- `void * realloc (void *ptr, size_t size);`

  Пытается перевыделить память, на которую указывает `ptr`, на size байт
  (например, запросили больше) и возвращает `ptr`. Если не хватает места для
  увеличения выделенной памяти, на которое указывает `ptr`, `realloc` создает новое выделение (аллокацию),
  копирует столько старых данных, на которые указывает `ptr`, сколько будет соответствовать новому выделению,
  освобождает старое выделение и возвращает указатель на выделенную память.

  Если `ptr` равен `NULL`, `realloc` идентичен вызову `malloc`.

  Если `size` равен нулю, а `ptr` не равен `NULL`, выделяется новый объект
  минимального размера и исходный объект освобождается.

  При расширении области, выделенной с помощью `calloc`, `realloc` не гарантирует,
  что дополнительная память также заполняется нулем.

- `void * reallocf (void *ptr, size_t size);`

  Придумка из FreeBSD API. Как и realloc, но если не сможет перевыделить, очищает
  принятый указатель.

- `void * valloc (size_t size);`

  Как и malloc, но выделенная память выравнивается по границе страницы.
